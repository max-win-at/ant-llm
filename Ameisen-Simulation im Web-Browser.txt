Stigmergische Netzwerk-Topologien: Eine bio-informatische Neuausrichtung

1. Paradigmenwechsel: Das Netzwerk als Habitat

In der ursprünglichen Konzeption fungierte der Browser-Tab als räumliche Arena, in der Ameisen als graphische Objekte über einen Canvas navigierten. In dieser modifizierten Architektur wird die pixelbasierte Umwelt durch den Adressraum des Netzwerks ersetzt. Die Ameisen "laufen" nicht mehr über Pixel, sondern agieren als echte Web-Agenten, die die Topographie des Internets durch Versuch, Irrtum und kollektives Gedächtnis kartieren.

Die neue Definition von Raum und Bewegung:

* Habitat: Ein Graph aus URLs (Knoten) und Latenzen (Kanten).
* Bewegung: Der Akt des fetch()-Aufrufs ist die physikalische Fortbewegung der Ameise.
* Distanz: Die Round-Trip-Time (RTT) entspricht der zurückgelegten Strecke. Eine hohe Latenz (z.B. 2000ms) simuliert ein weit entferntes oder schwergängiges Terrain (Sumpf/Dickicht).
* Position: Eine Ameise befindet sich nicht an Koordinaten, sondern in einem "Zustand des Requests" gegenüber einem spezifischen Endpunkt.

2. Physiologie der digitalen Ameise (Fetch-Kinetik)

Die Ameise ist kein graphisches Objekt mehr, das über einen Canvas läuft, sondern ein asynchroner Zustandsautomat, dessen Lebenszyklus durch Netzwerk-IO definiert ist.

Biologisches Attribut -> Technische Implementierung -> Beschreibung:
* Kinetik (Bewegung) -> fetch(url) -> Der Start des Requests ist der Abmarsch aus dem Nest.
* Reisezeit -> performance.now() - startTime -> Die Dauer des asynchronen Wartens ist die physische Fortbewegung.
* Metabolismus -> API-Payload (JSON) -> Die Komplexität des JSON (Entropie) definiert den Nährwert.
* Erschöpfung -> Timeout / Latenz-Penalty -> Ameisen, die zu lange in "Sümpfen" (langsamen APIs) feststecken, verlieren Energie.

Zustandsmodell der Ameise:
* idle: Die Ameise befindet sich im Nest und wartet auf den nächsten Einsatz.
* fetching: Die Ameise ist unterwegs — ein fetch()-Aufruf läuft. Dies ist der Zustand der aktiven Bewegung.
* returning: Die Ameise hat Nahrung erworben (200 OK) und kehrt zum Nest zurück.
* dead: Die Ameise hat keine Energie mehr oder wurde von einem Fressfeind terminiert.

3. Stigmergie 2.0: Temporale Pheromon-Datenpunkte

Anstatt chemische Spuren auf Pixeln zu hinterlassen, markieren die Agenten die Netzwerk-Knoten in einer zentralen Registry (IndexedDB).

Der Pheromon-Datenpunkt:
Jede erfolgreiche "Nahrungsaufnahme" (200 OK) hinterlässt einen Eintrag:

  { url: "api.pokeapi.co", intensity: 1.0, lastSeen: Date.now(), avgRTT: 120, visits: 5 }

Die Verfallslogik (Evaporation):
Pheromone verblassen nicht durch Grafik-Shader, sondern durch eine zeitabhängige Gewichtungsfunktion:

  effectiveIntensity = intensity * e^(-λ · Δt)

Wobei λ die Zerfallsrate der Information ist. Wenn eine Ressource lange nicht besucht wurde, sinkt ihre Attraktivität in der kollektiven Auswahl-Logik der Scouts.

Repellent-Signale:
Negative Pheromonwerte markieren gefährliche URLs. Wenn eine Ameise auf einen HTTP 5xx-Fehler trifft, wird die URL mit einem negativen Intensitätswert versehen, der andere Ameisen warnt.

4. Ökologie der Gefahren: Fressfeinde im REST-Raum

Das Internet ist ein gefährliches Ökosystem. Die "Fressfeinde" sind aktive Abwehrmechanismen der Server.

* Der Apex-Predator (HTTP 429): Ein "Ant-Lion". Zu gieriges Abgrasen eines Endpunkts führt zur sofortigen Terminierung der Ameise (Request-Abbruch) oder einer "Lähmung" (Back-off-Timer). Schadenswert: 50 Energieeinheiten.

* Das Unwetter (HTTP 5xx): Ein Zusammenbruch des Habitats. Die Pheromonspur zu dieser Ressource wird sofort mit einem "Repellent"-Faktor (negatives Pheromon) belegt, um die Kolonie zu warnen. Schadenswert: 30 Energieeinheiten.

* Der Sumpf (Timeout/Hohe Latenz): Energieverschwendung durch langsames Terrain. Jede Millisekunde RTT kostet Energie proportional zum Latenz-Penalty-Faktor. Ameisen können im Sumpf "verhungern".

* Die Camouflage (Redirect-Loops): Energieverschwendung durch endlose Bewegung ohne Nahrungsertrag. Schadenswert: 15 Energieeinheiten.

5. Nahrungsgüte und metabolische Verwertung

Die Ameise bewertet die "Beute" (den Response-Body) nach biologischen Kriterien:

* Zucker (Einfache Daten): Flache JSON-Strukturen (z.B. JSONPlaceholder Posts/Todos) für schnellen Energieaufbau. Werden als Cookies im Nest gespeichert. Nutrition-Multiplier: 0.8-1.0x.

* Protein (Strukturierte Daten): Tief verschachtelte Objekte (z.B. PokeAPI, REST Countries), die es der Kolonie erlauben, im Nest (Cookie-Speicher) neue "Brut" (neue Agenten-Instanzen) zu generieren. Nutrition-Multiplier: 1.5-2.0x.

Die strukturelle Komplexität (Entropie) wird durch rekursive Analyse der JSON-Tiefe berechnet. Jede Verschachtelungsebene trägt mit halbem Gewicht zum Gesamtscore bei.

6. Stigmergische Entscheidungsfindung: URL-Selektion

Die Kolonie nutzt pheromone-gewichtete Wahrscheinlichkeitsverteilungen für die Zielauswahl:

* Scouts (20% der Population): Bevorzugen niedrige oder unbekannte Pheromonwerte (Novelty-Seeking). Sie erkunden neue URLs und erweitern die Karte des Habitats.

* Workers (80% der Population): Folgen starken Pheromonspuren (Exploitation). Sie maximieren den Ertrag auf bewährten Pfaden.

Beide Rollen meiden URLs mit negativem Pheromonwert (Repellent), aber mit unterschiedlicher Intensität. Scouts sind mutiger, Workers vorsichtiger.

7. Persistenz und Speicherarchitektur

Speichermechanismus -> Biologisches Analogon -> Verwendung:
* LocalStorage -> Individuelles Gedächtnis -> Ant-Population (Zustand, Energie, besuchte URLs)
* IndexedDB -> Kollektives Wissen / Pheromonkarte -> Pheromon-Registry (URL → Intensität, RTT, Visits)
* Cookies -> Nahrungslager -> Food-Storage mit natürlichem Ablaufdatum (Verderblichkeit)

Die Ameisen sind vollständig serialisierbar und überleben Browser-Neustarts. Transiente Zustände (fetching) werden beim Laden auf idle zurückgesetzt.

8. Visualisierung: Der "Netzwerk-Bau"

Obwohl die Simulation logisch im Netzwerk stattfindet, benötigt der menschliche Beobachter eine Repräsentation. Anstelle von Ameisen auf einer Wiese sehen wir nun:

* Ein dynamisches Netzwerk-Diagramm (Force-Directed Graph) auf einem Canvas.
* Die Knoten pulsieren bei jedem fetch()-Aufruf.
* Die Dicke der Verbindungslinien (Kanten) visualisiert die Pheromonkonzentration (kollektive Präferenz).
* Die Entfernung der Knoten vom Zentrum (Nest) visualisiert die durchschnittliche RTT (Latenz = Terrain-Distanz).
* Ameisen erscheinen als Partikel, die sich entlang der Kanten bewegen:
  - Outbound (fetching): Vom Nest zum Zielknoten
  - Inbound (returning): Vom Knoten zum Nest, gelb markiert (Nahrung tragend)
* Ein Live-Activity-Feed zeigt die letzten fetch()-Ergebnisse mit Status, Hostname und RTT.

9. Konfiguration und Parameter

Simulation:
* Tick-Intervall: 1000ms (netzwerkgetaktet, nicht 20 FPS)
* Max. parallele Fetches: 3
* Forage-Cooldown: 5 Ticks

Ameise:
* Initialenergie: 80, Maximum: 100
* Energieverlust pro Tick: 0.15
* Energiegewinn bei Nahrungslieferung: 30
* Fetch-Timeout: 8000ms
* Latenz-Penalty-Faktor: 0.01 Energie/ms RTT

Pheromon:
* Zerfallsrate λ: 0.0001
* Initiale Intensität: 1.0
* Repellent-Intensität: -2.0
* Maximum: ±10

Kolonie:
* Initialgröße: 20 Ameisen
* Maximalgröße: 200 Ameisen
* Reproduktionsschwelle: 5 Cookies

10. Nahrungsquellen (Kostenlose APIs)

A. Zucker-Quellen (Flache JSON):
* JSONPlaceholder Posts: https://jsonplaceholder.typicode.com/posts/ (1.0x)
* JSONPlaceholder Todos: https://jsonplaceholder.typicode.com/todos/ (0.8x)

B. Protein-Quellen (Verschachtelte Objekte):
* PokeAPI: https://pokeapi.co/api/v2/pokemon/ (2.0x)
* REST Countries: https://restcountries.com/v3.1/all (1.5x)

C. Gefahren-Endpunkte:
* Ant-Lion (429): https://httpstat.us/429
* Storm (500): https://httpstat.us/500
* Swamp (Slow): https://httpstat.us/200?sleep=5000

11. Schlussfolgerung

Diese Modifikation macht die Simulation authentischer für das Medium Web. Die Ameisen agieren nicht mehr als Sprite-Objekte in einem Videospiel, sondern als echte Web-Agenten, die die Topographie des Internets durch Versuch, Irrtum und kollektives Gedächtnis kartieren. Der Adressraum des Netzwerks wird zum natürlichen Habitat, HTTP-Statuscodes werden zu ökologischen Kräften, und die Round-Trip-Time wird zur physikalischen Distanz.

Die Architektur besteht aus:
* Ant (ant.js): Asynchroner Zustandsautomat mit Fetch-Kinetik
* NetworkTopology (environment.js): Graph aus URL-Knoten
* PheromoneRegistry (pheromone.js): Temporale Datenpunkte mit exponentieller Zerfallsfunktion
* Colony (colony.js): Orchestrator mit stigmergischer Entscheidungsfindung
* CookieManager (cookie-manager.js): Nahrungslager mit natürlicher Verderblichkeit
* Renderer (renderer.js): Force-Directed-Graph-Visualisierung

Quellenangaben
1. Ant colony optimization algorithms - Wikipedia, https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms
2. Stigmergy in Antetic AI: Building Intelligence from Indirect Communication, https://www.alphanome.ai/post/stigmergy-in-antetic-ai-building-intelligence-from-indirect-communication
3. A Javascript Implementation of Ants - Nature, In Code, http://www.natureincode.com/code/various/ants.html
4. Difference Between localStorage and indexedDB in JavaScript - GeeksforGeeks, https://www.geeksforgeeks.org/javascript/difference-between-localstorage-and-indexeddb-in-javascript/
5. LocalStorage vs IndexedDB: Choosing the Right Solution for Your Web Application, https://shiftasia.com/community/localstorage-vs-indexeddb-choosing-the-right-solution-for-your-web-application/
6. Understanding Frontend Storage Solutions, https://medium.com/@vinciabhinav7/understanding-frontend-storage-solutions-local-storage-vs-cookies-vs-indexeddb-0c5a1367855a
7. Using Web Workers - Web APIs - MDN Web Docs, https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
8. Rank-Based Ant System with Originality Reinforcement - MDPI, https://www.mdpi.com/2076-3417/12/21/11219
9. Pheromone-Focused Ant Colony Optimization algorithm for path planning - arXiv, https://arxiv.org/html/2601.07597v1
10. Ant Colony Optimization - Finding shortest path in a graph, https://medium.com/@hasnain.roopawalla/ant-colony-optimization-1bbc346c2da5
11. Quorum sensing by encounter rates in the ant Temnothorax albipennis, https://academic.oup.com/beheco/article/16/2/488/297922
12. How ants use quorum sensing to estimate the average quality of a fluctuating resource, https://pubmed.ncbi.nlm.nih.gov/26153535/
13. Guide - JSONPlaceholder, https://jsonplaceholder.typicode.com/guide/
14. httpstat.us, https://ab-as-httpstatus-app1.azurewebsites.net/
15. HTTP response status codes - MDN Web Docs, https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status
16. Force simulations | D3 by Observable, https://d3js.org/d3-force/simulation
17. vis.js network documentation, https://visjs.org/
18. Multi-agent systems powered by large language models: applications in swarm intelligence, https://www.frontiersin.org/journals/artificial-intelligence/articles/10.3389/frai.2025.1593017/full
